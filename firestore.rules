rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function signedIn() {
      return request.auth != null;
    }

    function userPath(orgId) {
      return /databases/$(database)/documents/organisations/$(orgId)/users/$(request.auth.uid);
    }

    function hasUser(orgId) {
      return signedIn() && exists(userPath(orgId));
    }

    function userData(orgId) {
      return get(userPath(orgId)).data;
    }

    function inOrg(orgId) {
      return hasUser(orgId)
        && userData(orgId).orgId == orgId
        && userData(orgId).isActive == true;
    }

    function isSuperadmin() {
      return signedIn()
        && request.auth.token is map
        && ('superadmin' in request.auth.token)
        && request.auth.token.superadmin == true;
    }

    function isOrgAdmin(orgId) {
      return inOrg(orgId) && userData(orgId).role == 'org_admin';
    }

    function hasSchoolScope(orgId, schoolId) {
      return inOrg(orgId)
        && (
          isOrgAdmin(orgId)
          || (userData(orgId).schoolIds is list && userData(orgId).schoolIds.hasAny([schoolId]))
        );
    }

    function hasAnySchoolScope(orgId, schoolIds) {
      return inOrg(orgId)
        && (
          isOrgAdmin(orgId)
          || (schoolIds is list
              && userData(orgId).schoolIds is list
              && userData(orgId).schoolIds.hasAny(schoolIds))
        );
    }

    function isSelfStaff(orgId, staffId) {
      return inOrg(orgId) && userData(orgId).staffId == staffId;
    }

    function isViewer(orgId) {
      return inOrg(orgId) && userData(orgId).role == 'viewer';
    }

    function isSchoolAdmin(orgId) {
      return inOrg(orgId) && userData(orgId).role == 'school_admin';
    }

    function canReadOrgScoped(orgId) {
      return isSuperadmin() || inOrg(orgId);
    }

    function canWriteOrgScoped(orgId) {
      return isSuperadmin() || isOrgAdmin(orgId);
    }

    function canReadAggregate(orgId) {
      return isSuperadmin()
        || (
          inOrg(orgId)
          && userData(orgId).role != 'staff'
        );
    }

    function canReadAudit(orgId) {
      return isSuperadmin()
        || isOrgAdmin(orgId)
        || isSchoolAdmin(orgId)
        || isViewer(orgId);
    }

    function hasModuleEntitlement(orgId, moduleId) {
      return inOrg(orgId)
        && userData(orgId).enabledModules is list
        && userData(orgId).enabledModules.hasAny([moduleId]);
    }

    function canAccessModule(orgId, moduleId) {
      return isSuperadmin() || hasModuleEntitlement(orgId, moduleId);
    }

    match /organisations/{orgId} {
      allow read: if canReadOrgScoped(orgId);
      allow create, update, delete: if canWriteOrgScoped(orgId);

      match /schools/{schoolId} {
        allow read: if canReadOrgScoped(orgId) && hasSchoolScope(orgId, schoolId);
        allow create, update, delete: if canWriteOrgScoped(orgId) || (isSchoolAdmin(orgId) && hasSchoolScope(orgId, schoolId));
      }

      match /users/{uid} {
        allow read: if canReadOrgScoped(orgId)
          && (isOrgAdmin(orgId) || uid == request.auth.uid || hasAnySchoolScope(orgId, resource.data.schoolIds));

        allow create, update, delete: if canWriteOrgScoped(orgId);
      }

      match /staff/{staffId} {
        allow read: if canReadOrgScoped(orgId)
          && (
            isOrgAdmin(orgId)
            || ((isSchoolAdmin(orgId) || isViewer(orgId)) && hasAnySchoolScope(orgId, resource.data.schoolIds))
            || isSelfStaff(orgId, staffId)
          );

        allow create, update, delete: if canWriteOrgScoped(orgId)
          || (isSchoolAdmin(orgId) && hasAnySchoolScope(orgId, request.resource.data.schoolIds));
      }

      match /moduleHealth/{moduleId} {
        allow read: if canReadAggregate(orgId) && canAccessModule(orgId, moduleId);
        // Module health should be written by trusted server paths (Admin SDK), not client SDK.
        allow create, update, delete: if false;
      }

      match /aggregates/{aggregateId} {
        allow read: if canReadAggregate(orgId);
        // Aggregates should be written by trusted server paths (Admin SDK), not client SDK.
        allow create, update, delete: if false;
      }

      // Module-owned collections (SchoolTrack core + modules model)
      match /modules/{moduleId} {
        match /trainingTypes/{trainingTypeId} {
          allow read: if moduleId == 'trainingTrack'
            && canAccessModule(orgId, moduleId)
            && canReadOrgScoped(orgId);
          allow create, update, delete: if moduleId == 'trainingTrack'
            && canAccessModule(orgId, moduleId)
            && canWriteOrgScoped(orgId);
        }

        match /trainingRecords/{recordId} {
          allow read: if moduleId == 'trainingTrack'
            && canAccessModule(orgId, moduleId)
            && canReadOrgScoped(orgId)
            && (
              isOrgAdmin(orgId)
              || hasSchoolScope(orgId, resource.data.schoolId)
              || isSelfStaff(orgId, resource.data.staffId)
            );

          // Admin/school_admin path. Staff self-submit is optional and constrained.
          allow create, update: if moduleId == 'trainingTrack'
            && canAccessModule(orgId, moduleId)
            && (
              canWriteOrgScoped(orgId)
              || (isSchoolAdmin(orgId) && hasSchoolScope(orgId, request.resource.data.schoolId))
              || (inOrg(orgId)
                  && userData(orgId).role == 'staff'
                  && request.resource.data.staffId == userData(orgId).staffId
                  && hasSchoolScope(orgId, request.resource.data.schoolId)
                  && !('status' in request.resource.data)
                  && !('daysToExpiry' in request.resource.data))
            );

          allow delete: if moduleId == 'trainingTrack'
            && canAccessModule(orgId, moduleId)
            && (canWriteOrgScoped(orgId) || (isSchoolAdmin(orgId) && hasSchoolScope(orgId, resource.data.schoolId)));
        }

        match /auditLogs/{logId} {
          allow read: if moduleId == 'trainingTrack'
            && canAccessModule(orgId, moduleId)
            && canReadAudit(orgId);
          // Immutable: create only.
          allow create: if moduleId == 'trainingTrack'
            && canAccessModule(orgId, moduleId)
            && (canWriteOrgScoped(orgId) || isSchoolAdmin(orgId));
          allow update, delete: if false;
        }

        // Deny all other module-owned collections by default until explicitly added.
        match /{document=**} {
          allow read, write: if false;
        }
      }
    }
  }
}
